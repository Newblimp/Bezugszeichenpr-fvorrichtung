#!/usr/bin/env python3
"""
Embed ONNX model files as uncompressed hex arrays in C++

Converts binary model files to C++ source code with embedded hex data.
Each model becomes a const uint8_t array with accompanying size constant.
"""

import argparse
import os
import sys


def bytes_to_hex_array(data, bytes_per_line=16):
    """Convert binary data to formatted hex array lines."""
    lines = []
    for i in range(0, len(data), bytes_per_line):
        chunk = data[i:i + bytes_per_line]
        hex_bytes = ', '.join(f'0x{b:02x}' for b in chunk)
        lines.append(f'    {hex_bytes},')
    return lines


def generate_cpp_file(det_model_path, rec_model_path, output_path):
    """Generate C++ source file with embedded models."""

    # Read model files
    print(f"Reading detection model: {det_model_path}")
    with open(det_model_path, 'rb') as f:
        det_data = f.read()

    print(f"Reading recognition model: {rec_model_path}")
    with open(rec_model_path, 'rb') as f:
        rec_data = f.read()

    print(f"Detection model size: {len(det_data)} bytes")
    print(f"Recognition model size: {len(rec_data)} bytes")

    # Convert to hex arrays
    det_hex_lines = bytes_to_hex_array(det_data)
    rec_hex_lines = bytes_to_hex_array(rec_data)

    # Generate C++ code
    cpp_code = """#ifdef HAVE_OPENCV

#include <cstdint>
#include <cstddef>

// Auto-generated: Do not edit manually
// Embedded uncompressed ONNX models for PaddleOCR
// Generated by embed_models.py

"""

    # Detection model
    cpp_code += f"""// Detection model (DBNet)
// Size: {len(det_data)} bytes
extern const uint8_t det_model_uncompressed[] = {{
"""
    cpp_code += '\n'.join(det_hex_lines)
    cpp_code += f"""
}};
extern const size_t det_model_uncompressed_size = {len(det_data)};

"""

    # Recognition model
    cpp_code += f"""// Recognition model (CRNN)
// Size: {len(rec_data)} bytes
extern const uint8_t rec_model_uncompressed[] = {{
"""
    cpp_code += '\n'.join(rec_hex_lines)
    cpp_code += f"""
}};
extern const size_t rec_model_uncompressed_size = {len(rec_data)};

#endif // HAVE_OPENCV
"""

    # Write output file
    print(f"Writing output: {output_path}")
    with open(output_path, 'w') as f:
        f.write(cpp_code)

    print("Model embedding completed successfully")


def main():
    parser = argparse.ArgumentParser(
        description='Embed ONNX models as uncompressed hex arrays in C++')
    parser.add_argument('--det', required=True, help='Path to detection model (det.onnx)')
    parser.add_argument('--rec', required=True, help='Path to recognition model (rec.onnx)')
    parser.add_argument('--output', required=True, help='Output C++ file path')

    args = parser.parse_args()

    # Validate input files
    if not os.path.exists(args.det):
        print(f"Error: Detection model not found: {args.det}", file=sys.stderr)
        sys.exit(1)

    if not os.path.exists(args.rec):
        print(f"Error: Recognition model not found: {args.rec}", file=sys.stderr)
        sys.exit(1)

    # Create output directory if needed
    output_dir = os.path.dirname(args.output)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)

    try:
        generate_cpp_file(args.det, args.rec, args.output)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
